<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>7.Map接口及其实现类 | Jilfoyle</title><meta name="keywords" content="后端,java"><meta name="author" content="Jilfoyle"><meta name="copyright" content="Jilfoyle"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="黯相望。断鸿声里，立尽斜阳。 ——柳永《玉蝴蝶》">
<meta property="og:type" content="article">
<meta property="og:title" content="7.Map接口及其实现类">
<meta property="og:url" content="https://jilfoyle-9527.github.io/2022/07/22/7.Map%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB/index.html">
<meta property="og:site_name" content="Jilfoyle">
<meta property="og:description" content="黯相望。断鸿声里，立尽斜阳。 ——柳永《玉蝴蝶》">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jilfoyle-9527.github.io/medias/java/cover.jpg">
<meta property="article:published_time" content="2022-07-22T07:38:31.000Z">
<meta property="article:modified_time" content="2023-04-12T04:00:49.403Z">
<meta property="article:author" content="Jilfoyle">
<meta property="article:tag" content="后端">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jilfoyle-9527.github.io/medias/java/cover.jpg"><link rel="shortcut icon" href="/img/index.ico"><link rel="canonical" href="https://jilfoyle-9527.github.io/2022/07/22/7.Map%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '7.Map接口及其实现类',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-12 12:00:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://img2.baidu.com/it/u=343850545,2320437498&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">262</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">68</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/medias/java/cover.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Jilfoyle</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">7.Map接口及其实现类</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-22T07:38:31.000Z" title="发表于 2022-07-22 15:38:31">2022-07-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-12T04:00:49.403Z" title="更新于 2023-04-12 12:00:49">2023-04-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%BC%80%E5%8F%91%E8%B7%AF%E7%BA%BF/">Java开发路线</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%BC%80%E5%8F%91%E8%B7%AF%E7%BA%BF/3-JavaSE/">3.JavaSE</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%BC%80%E5%8F%91%E8%B7%AF%E7%BA%BF/3-JavaSE/2-JavaSE-%E9%9B%86%E5%90%88/">2.JavaSE-集合</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="7.Map接口及其实现类"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>黯相望。断鸿声里，立尽斜阳。</p>
<p align="right">——柳永《玉蝴蝶》</p>
<span id="more"></span>


<h1 id="Map接口及其实现类"><a href="#Map接口及其实现类" class="headerlink" title="Map接口及其实现类"></a>Map接口及其实现类</h1><h2 id="1-Map接口介绍"><a href="#1-Map接口介绍" class="headerlink" title="1. Map接口介绍"></a>1. Map接口介绍</h2><blockquote>
<ol>
<li>现实生活中，我们常会看到这样的一种集合：<code>IP</code>地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种<code>一一对应</code>的关系，就叫做映射。<code>Java</code>提供了专门的集合类用来存放这种对象关系的对象，即 <code>java.util.Map</code> 接口。</li>
<li>Map与Collection并列存在。用于保存具有<code>映射关系的数据:key-value。</code></li>
<li>Map 中的 key 和 value 都可以是任何引用类型的数据</li>
<li><code>Map 中的 key 用Set来存放， 不允许重复，即同一个 Map 对象所对应的类，须重写hashCode()和equals()方法</code><ul>
<li><code>常用String类作为Map的“键”。</code></li>
<li><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/image-20201113172115578.png" alt="image-20201113172115578"></li>
</ul>
</li>
<li>key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value。</li>
<li>Map接口中的集合都有两个泛型变量,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量的数据类型可以相同，也可以不同。</li>
<li>Map接口的常用实现类：<code>HashMap</code>、<code>TreeMap</code>、<code>LinkedHashMap</code>和<code>Properties</code>。<code>其中HashMap是 Map 接口使用频率最高的实现类</code></li>
</ol>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20201113230328581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTI2NzEwMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="2-Map接口中常用方法"><a href="#2-Map接口中常用方法" class="headerlink" title="2. Map接口中常用方法"></a>2. Map接口中常用方法</h2><h4 id="元素的添加-、-删除、修改操作"><a href="#元素的添加-、-删除、修改操作" class="headerlink" title="元素的添加 、 删除、修改操作"></a>元素的添加 、 删除、修改操作</h4><blockquote>
<p><code>Object put(Object key,Object value)：</code>将指定key-value<code>添加到(或修改)</code>当前map对象中。</p>
<p><code>void putAll(Map m):</code>将m中的所有key-value对存放到当前map中。</p>
<p><code>Object remove(Object key)：</code>移除指定key的key-value对，并返回value。</p>
<p><code>void clear()：</code>清空当前map中的所有数据。</p>
</blockquote>
<h4 id="元素查询的操作"><a href="#元素查询的操作" class="headerlink" title="元素查询的操作"></a>元素查询的操作</h4><blockquote>
<p><code>Object get(Object key)：</code>获取指定key对应的value。</p>
<p><code>boolean containsKey(Object key)：</code>是否包含指定的key。</p>
<p><code>boolean containsValue(Object value)：</code>是否包含指定的value。</p>
<p><code>int size()：</code>返回map中key-value对的个数。</p>
<p><code>boolean isEmpty()：</code>判断当前map是否为空。</p>
<p><code>boolean equals(Object obj)：</code>判断当前mp和参数对象obj是否相等。</p>
</blockquote>
<h4 id="遍历Map的三种方式☆"><a href="#遍历Map的三种方式☆" class="headerlink" title="遍历Map的三种方式☆"></a>遍历Map的三种方式☆</h4><blockquote>
<p><code>public Set&lt;K&gt; keySet()</code> : 获取Map集合中所有的键，存储到Set集合中。</p>
<ul>
<li><p>获取<code>Map</code>中所有的键，由于键是唯一的，所以返回一个<code>Set</code>集合存储所有的键。方法提示: <code>keyset()</code></p>
</li>
<li><p>遍历键的<code>Set</code>集合，得到每一个键。</p>
</li>
<li><p>根据键，获取键所对应的值。方法提示: <code>get(K key)</code></p>
</li>
</ul>
<p><code>Collection values()：</code>返回所有value构成的Collection集合</p>
<p><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code> : 获取到Map集合中所有的键值对对象的集合(Set集合)。</p>
<ul>
<li><p>我们已经知道， <code>Map</code> 中存放的是两种对象，一种称为key(键)，一种称为<code>value</code>(值)，它们在在 <code>Map</code> 中是一一对应关系，这一对对象又称做 <code>Map</code> 中的一个 <code>Entry</code>(项) 。 <code>Entry</code> 将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历 <code>Map</code> 集合时，就可以从每一个键值对（ <code>Entry</code> ）对象中获取对应的键与对应的值。既然<code>Entry</code>表示了一对键和值，那么也同样提供了获取对应键和对应值得方法：</p>
</li>
<li><p>Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。</p>
<ul>
<li><p>public K getKey() ：获取Entry对象中的键。</p>
</li>
<li><p>public V getValue() ：获取Entry对象中的值。</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/11/13 17:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 10.21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> DuanChaojie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 集合初始化时，指定集合初始值大小</span></span><br><span class="line">        <span class="comment">// 说明:HashMap使用如下构造方法进行初始化，如果暂时无法确定集合大小，那么指定默认值（16）即可</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//map.put(..,..)省略</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;map的所有key:&quot;</span>);</span><br><span class="line">        <span class="comment">// HashSet</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">keys</span> <span class="operator">=</span> map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (Object key : keys) &#123;</span><br><span class="line">            System.out.println(key + <span class="string">&quot;-&gt;&quot;</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;map的所有的value：&quot;</span>);</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iter</span> <span class="operator">=</span> values.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            System.out.println(iter.next());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;map所有的映射关系：&quot;</span>);</span><br><span class="line">        <span class="comment">// 映射关系的类型是Map.Entry类型，它是Map接口的内部接口</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">mappings</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Object mapping : mappings) &#123;</span><br><span class="line">            Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) mapping;</span><br><span class="line">            System.out.println(<span class="string">&quot;key是：&quot;</span> + entry.getKey() + <span class="string">&quot;，value是：&quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Map接口的实现类"><a href="#3-Map接口的实现类" class="headerlink" title="3. Map接口的实现类"></a>3. Map接口的实现类</h2><h3 id="3-1-HashMap集合"><a href="#3-1-HashMap集合" class="headerlink" title="3.1 HashMap集合"></a>3.1 HashMap集合</h3><blockquote>
<ol>
<li><code>HashMap是 Map 接口 使用频率最高的实现类。</code></li>
<li>允许使用null键和null值，与HashSet一样，不保证映射的顺序。</li>
<li><code>所有的key构成的集合是Set:无序的、不可重复的。所以，key所在的类要重写：equals()和hashCode()。</code></li>
<li>所有的value构成的集合是Collection:无序的、可以重复的。<code>所以，value所在的类要重写：equals()。</code></li>
<li>==一个key-value构成一个entry==</li>
<li>所有的entry构成的集合是Set:无序的、不可重复的</li>
<li>HashMap  <code>判断两个 key  相等的标准是</code>：两个 key 通过 equals() 方法返回 true，hashCode 值也相等。<ul>
<li>因为key不允许有重复。</li>
</ul>
</li>
<li>HashMap  <code>判断两个 value 相等的标准是</code>：两个 value 通过 equals() 方法返回 true。</li>
</ol>
</blockquote>
<h5 id="HashMap源码中的重要常量☆"><a href="#HashMap源码中的重要常量☆" class="headerlink" title="HashMap源码中的重要常量☆"></a>HashMap源码中的重要常量☆</h5><blockquote>
<ol>
<li><p><code>DEFAULT_INITIAL_CAPACITY :</code> HashMap的默认容量，16</p>
</li>
<li><p><code>MAXIMUM_CAPACITY ：</code> HashMap的最大支持容量，2^30</p>
</li>
<li><p><code>DEFAULT_LOAD_FACTOR ：</code>HashMap的默认加载因子0.75</p>
</li>
<li><p><code>TREEIFY_THRESHOLD ：</code>Bucket中链表长度大于该默认值8，转化为红黑树</p>
</li>
<li><p><code>UNTREEIFY_THRESHOLD ：</code>Bucket中红黑树存储的Node小于该默认值6，转化为链表。</p>
</li>
<li><p><code>MIN_TREEIFY_CAPACITY ：</code>==桶中的Node被树化时最小的hash表容量==。（当桶中Node的数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行resize扩容操作这个MIN_TREEIFY_CAPACITY的值<code>（默认为64）</code>至少是TREEIFY_THRESHOLD的4倍。）</p>
</li>
<li><p><code>table ：</code>存储元素的数组，总是2的n次幂</p>
</li>
<li><p><code>entrySet：</code> 存储具体元素的集</p>
</li>
<li><p><code>size ：</code>HashMap中存储的键值对的数量</p>
</li>
<li><p><code>modCount ：</code>HashMap扩容和结构改变的次数。</p>
</li>
<li><p><code>threshold ：</code>扩容的临界值（吞吐临界值）12=容量*填充因子</p>
</li>
<li><p><code>loadFactor：</code> 填充比（负载因子）。</p>
<ol>
<li><p>负载因子值的大小，对HashMap有什么影响？</p>
<ul>
<li><p>负载因子的大小决定了HashMap的数据密度。</p>
</li>
<li><p>负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长,造成查询或插入时的比较次数增多，性能会下降。</p>
</li>
<li><p>负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间。</p>
</li>
<li><p>按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数。</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</blockquote>
<h5 id="HashMap的储存结构☆☆"><a href="#HashMap的储存结构☆☆" class="headerlink" title="HashMap的储存结构☆☆"></a>HashMap的储存结构☆☆</h5><blockquote>
<ol>
<li>JDK 7及以前版本：HashMap是数组+链表结构(即为链地址法)。</li>
<li>JDK 8版本发布以后：HashMap是数组+链表+红黑树实现。</li>
</ol>
</blockquote>
<h6 id="JDK7"><a href="#JDK7" class="headerlink" title="JDK7"></a>JDK7</h6><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/image-20201113211938573.png" alt="image-20201113211938573"></p>
<blockquote>
<ol>
<li><p>HashMap的内部存储结构其实是 数组和链表的结合。当实例化一个HashMap时，系统会创建一个长度为Capacity的Entry数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。</p>
</li>
<li><p>每个bucket中存储一个元素，即一个Entry对象，但每一个Entry对象可以带一个引用变量，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Entry链。而且新添加的元素作为链表的head。</p>
</li>
<li><p>HashMap静态内部类Entry</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       V value;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">       Entry&lt;K,V&gt; next;</span><br><span class="line">    	<span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>==添加元素的过程：==</p>
<ol>
<li>向HashMap中添加entry1(key，value)，需要首先计算entry1中key的哈希值(根据key所在类的hashCode()计算得到)，此哈希值经过处理以后，得到在底层Entry[]数组中要<code>存储的位置i</code>。</li>
<li>如果位置i上没有元素，则entry1直接添加成功。如果位置i上已经存在entry2(或还有链表存在的entry3，entry4)，则需要通过循环的方法，依次比较entry1中key和其他的entry。如果彼此hash值不同，则直接添加成功。</li>
<li>如果hash值不同，继续比较二者是否equals。如果返回值为true，则使用entry1的value<br>去替换equals为true的entry的value。</li>
<li>如果遍历一遍以后，发现所有的equals返回都为false,则entry1仍可添加成功。entry1指向原有的entry元素。</li>
</ol>
</li>
<li><p>==HashMap 的扩容：==</p>
<ol>
<li>当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，<code>而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</code></li>
<li>那么HashMap 什么时候进行扩容呢 ？<ol>
<li>当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size)loadFactor 时 ， 就 会 进 行 数 组 扩 容 ， loadFactor 的 默 认 值(DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。</li>
<li>也就是说，默认情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中元素个数超过<code>16*0.75=12</code>（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，<code>所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</code></li>
</ol>
</li>
</ol>
</li>
</ol>
</blockquote>
<h6 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h6><p><img src="https://oss-blogs.oss-cn-hangzhou.aliyuncs.com/blogs/itbuild/JavaSE-%E9%9B%86%E5%90%88/image-20201113212003964.png" alt="image-20201113212003964"></p>
<blockquote>
<ol>
<li><p>HashMap的内部存储结构其实是 <code>数组+ 链表+ 树</code> 的结合。当实例化一个HashMap时，会初始化initialCapacity和loadFactor，在put第一对映射关系时，系统会创建一个长度为initialCapacity的<code>Node数组</code>，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为<br>“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。</p>
</li>
<li><p><code>每个bucket中存储一个元素，即一个Node对象，</code>但每一个Node对象可以带一个引用变量next，用于指向下一个元素，<code>因此，在一个桶中，就有可能生成一个Node链。也可能是一个一个TreeNode对象，</code>每一个TreeNode对象可以有两个叶子结点left和right，因此，在一个桶中，就有可能生成一个TreeNode树。<code>而新添加的元素作为链表的last，或树的叶子结点。</code></p>
</li>
<li><p>HashMap的静态内部类Node</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">   </span><br><span class="line">    Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.hash = hash;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>那么HashMap 什么时候进行扩容和树形化呢 ？</p>
<ol>
<li>当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size)loadFactor 时 ， 就会 进 行 数 组 扩 容 ， loadFactor 的 默 认 值(DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中元素个数超过<code>16*0.75=12</code>（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</li>
<li><code>当HashMap中的其中一个链的对象个数如果达到了8个，此时如果capacity没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链会变成树，结点类型由Node变成TreeNode类型。当然，如果当映射关系被移除后，下次resize方法时判断树的结点个数低于6个，也会把树再转为链表。</code><ul>
<li>如果不理解这段，可以看一下HashMap源码中的重要常量<code>MIN_TREEIFY_CAPACITY </code>。</li>
</ul>
</li>
</ol>
</li>
<li><p>关于映射关系的key 是否可以修改 ？</p>
<ul>
<li><p>答案是：不要修改！</p>
</li>
<li><p><code>映射关系存储到HashMap中会存储key的hash值，这样就不用在每次查找时重新计算每一个Entry或Node（TreeNode）的hash值了，因此如果已经put到Map中的映射关系，再修改key的属性，而这个属性又参与hashcode值的计算，那么会导致匹配不上。</code></p>
</li>
</ul>
</li>
</ol>
</blockquote>
<h6 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h6><blockquote>
<p><code>JDK1.8相较于之前的变化：</code></p>
<ol>
<li>HashMap map = new HashMap();//默认情况下，先不创建长度为16的数组。</li>
<li><code>当首次调用map.put()时，再创建长度为16的数组。</code></li>
<li><code>数组为Node类型，在jdk7中称为Entry类型。</code></li>
<li><code>形成链表结构时，新添加的key-value对在链表的尾部（七上八下）。</code></li>
<li><code>当数组指定索引位置的链表长度&gt;8时，且map中的数组的长度&gt; 64时，此索引位置上的所有key-value对使用红黑树进行存储。</code></li>
</ol>
</blockquote>
<h5 id="HashMap存储自定义类型键值"><a href="#HashMap存储自定义类型键值" class="headerlink" title="HashMap存储自定义类型键值"></a>HashMap存储自定义类型键值</h5><blockquote>
<ol>
<li>每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到<code>map</code>集合中。学生作为键, 家庭住址作为值。</li>
<li>注意，学生姓名相同并且年龄相同视为同一名学生。</li>
</ol>
</blockquote>
<h6 id="Student-java"><a href="#Student-java" class="headerlink" title="Student.java"></a>Student.java</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp; Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="测试类HashMapTest"><a href="#测试类HashMapTest" class="headerlink" title="测试类HashMapTest"></a>测试类HashMapTest</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1,创建Hashmap集合对象。</span></span><br><span class="line">        Map&lt;Student,String&gt;map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Student,String&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2,添加元素。</span></span><br><span class="line">        map.put(newStudent(<span class="string">&quot;lisi&quot;</span>,<span class="number">28</span>), <span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">&quot;wangwu&quot;</span>,<span class="number">22</span>), <span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">&quot;zhaoliu&quot;</span>,<span class="number">24</span>), <span class="string">&quot;成都&quot;</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">&quot;zhouqi&quot;</span>,<span class="number">25</span>),<span class="string">&quot;广州&quot;</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">&quot;wangwu&quot;</span>,<span class="number">22</span>), <span class="string">&quot;南京&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3,取出元素。键找值方式</span></span><br><span class="line">        Set&lt;Student&gt;keySet = map.keySet();</span><br><span class="line">        <span class="keyword">for</span>(Student key: keySet)&#123;</span><br><span class="line">            Stringvalue = map.get(key);</span><br><span class="line">            System.out.println(key.toString()+<span class="string">&quot;.....&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><p>当给<code>HashMap</code>中存放自定义对象时，如果自定义对象作为<code>key</code>存在，这时要保证对象唯一，必须复写对象的<code>hashCode</code>和<code>equals</code>方法(如果忘记，请回顾<code>HashSet</code>存放自定义对象)。</p>
</li>
<li><p>如果要保证<code>map</code>中存放的<code>key</code>和取出的顺序一致，可以使用 <code>java.util.LinkedHashMap</code> 集合来存放。</p>
</li>
</ol>
</blockquote>
<h5 id="LinkedHashMap集合☆"><a href="#LinkedHashMap集合☆" class="headerlink" title="LinkedHashMap集合☆"></a>LinkedHashMap集合☆</h5><blockquote>
<ol>
<li>我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？</li>
<li>LinkedHashMap 是 HashMap 的子类，它是链表和哈希表组合的一个数据存储结构。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LinkedHashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;邓超&quot;</span>, <span class="string">&quot;孙俪&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;李晨&quot;</span>, <span class="string">&quot;范冰冰&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;刘德华&quot;</span>, <span class="string">&quot;朱丽倩&quot;</span>);</span><br><span class="line">        Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot; &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">邓超 孙俪</span><br><span class="line">李晨 范冰冰</span><br><span class="line">刘德华 朱丽倩</span><br></pre></td></tr></table></figure>

<h6 id="LinkedHashMap的静态内部类Entry"><a href="#LinkedHashMap的静态内部类Entry" class="headerlink" title="LinkedHashMap的静态内部类Entry"></a>LinkedHashMap的静态内部类Entry</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-TreeMap集合"><a href="#3-2-TreeMap集合" class="headerlink" title="3.2 TreeMap集合"></a>3.2 TreeMap集合</h3><blockquote>
<ol>
<li>TreeMap存储 Key-Value 对时，需要根据 key-value 对进行排序。TreeMap 可以保证所有的 Key-Value 对处于有序状态。</li>
<li>TreeSet底层使用 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45267102/article/details/108424364">红黑树</a> 结构存储数据。</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45267102/article/details/109678514">TreeMap 的 Key 的排序：</a><ul>
<li><code>自然排序：</code>TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException。</li>
<li><code>定制排序：</code>创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现Comparable 接口</li>
</ul>
</li>
<li><code>TreeMap判断两个key 相等的标准：两个key通过compareTo()方法或者compare()方法返回0。</code></li>
</ol>
</blockquote>
<h3 id="3-3-HashTable集合"><a href="#3-3-HashTable集合" class="headerlink" title="3.3 HashTable集合"></a>3.3 HashTable集合</h3><blockquote>
<ol>
<li>HashTable是个古老的 Map 实现类，JDK1.0就提供了。<code>不同于HashMap，Hashtable是线程安全的。</code></li>
<li>Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用。</li>
<li><code>与HashMap不同，Hashtable 不允许使用 null 作为 key 和 value</code></li>
<li>与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序</li>
<li>Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。</li>
</ol>
</blockquote>
<h5 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h5><blockquote>
<ol>
<li><p>Properties 类是 Hashtable 的子类，该对象用于处理属性文件由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key和 value 都是字符串类型</p>
</li>
<li><p>存取数据时，建议使用<code>setProperty(String key,String value)方法</code>和<code>getProperty(String key)方法。</code></p>
</li>
<li><pre><code class="java">Properties pros = new Properties();
pros.load(new FileInputStream(&quot;jdbc.properties&quot;));
String user = pros.getProperty(&quot;user&quot;);
System.out.println(user);
</code></pre>
</li>
</ol>
</blockquote>
<h1 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://jilfoyle-9527.github.io">Jilfoyle</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jilfoyle-9527.github.io/2022/07/22/7.Map%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB/">https://jilfoyle-9527.github.io/2022/07/22/7.Map%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jilfoyle-9527.github.io" target="_blank">Jilfoyle</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%90%8E%E7%AB%AF/">后端</a><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="/medias/java/cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/22/7.MySql%E9%AB%98%E7%BA%A7%E4%B9%8B%E4%BC%98%E5%8C%96SQL%E6%AD%A5%E9%AA%A4/"><img class="prev-cover" src="/medias/database/mysql.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">7.MySql高级之优化SQL步骤</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/22/8.JDK8%E6%96%B0%E7%89%B9%E6%80%A7--Stream%20API/"><img class="next-cover" src="/medias/java/cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">8.JDK8新特性--Stream API</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://img2.baidu.com/it/u=343850545,2320437498&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Jilfoyle</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">262</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">68</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">暑往寒来春复秋，夕阳西下水东流</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Map%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">Map接口及其实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Map%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">1. Map接口介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Map%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">2. Map接口中常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E7%9A%84%E6%B7%BB%E5%8A%A0-%E3%80%81-%E5%88%A0%E9%99%A4%E3%80%81%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">元素的添加 、 删除、修改操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">元素查询的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86Map%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E2%98%86"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">遍历Map的三种方式☆</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Map%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text">3. Map接口的实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-HashMap%E9%9B%86%E5%90%88"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 HashMap集合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HashMap%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E5%B8%B8%E9%87%8F%E2%98%86"><span class="toc-number">1.3.1.0.1.</span> <span class="toc-text">HashMap源码中的重要常量☆</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HashMap%E7%9A%84%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84%E2%98%86%E2%98%86"><span class="toc-number">1.3.1.0.2.</span> <span class="toc-text">HashMap的储存结构☆☆</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#JDK7"><span class="toc-number">1.3.1.0.2.1.</span> <span class="toc-text">JDK7</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#JDK8"><span class="toc-number">1.3.1.0.2.2.</span> <span class="toc-text">JDK8</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.3.1.0.2.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HashMap%E5%AD%98%E5%82%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E9%94%AE%E5%80%BC"><span class="toc-number">1.3.1.0.3.</span> <span class="toc-text">HashMap存储自定义类型键值</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Student-java"><span class="toc-number">1.3.1.0.3.1.</span> <span class="toc-text">Student.java</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%B1%BBHashMapTest"><span class="toc-number">1.3.1.0.3.2.</span> <span class="toc-text">测试类HashMapTest</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LinkedHashMap%E9%9B%86%E5%90%88%E2%98%86"><span class="toc-number">1.3.1.0.4.</span> <span class="toc-text">LinkedHashMap集合☆</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#LinkedHashMap%E7%9A%84%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BBEntry"><span class="toc-number">1.3.1.0.4.1.</span> <span class="toc-text">LinkedHashMap的静态内部类Entry</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-TreeMap%E9%9B%86%E5%90%88"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 TreeMap集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-HashTable%E9%9B%86%E5%90%88"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 HashTable集合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Properties%E7%B1%BB"><span class="toc-number">1.3.3.0.1.</span> <span class="toc-text">Properties类</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%98%86"><span class="toc-number">2.</span> <span class="toc-text">☆</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/04/15/book/" title="书架"><img src="/medias/book/book.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="书架"/></a><div class="content"><a class="title" href="/2023/04/15/book/" title="书架">书架</a><time datetime="2023-04-15T13:03:19.424Z" title="发表于 2023-04-15 21:03:19">2023-04-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/12/Springboot(%E5%90%88%E9%9B%86)/" title="SpringBoot(合集)"><img src="/medias/springboot/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot(合集)"/></a><div class="content"><a class="title" href="/2023/04/12/Springboot(%E5%90%88%E9%9B%86)/" title="SpringBoot(合集)">SpringBoot(合集)</a><time datetime="2023-04-12T07:53:42.161Z" title="发表于 2023-04-12 15:53:42">2023-04-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/12/Springboot-security(%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6)/" title="Springboot-security(权限控制)"><img src="/medias/springboot/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Springboot-security(权限控制)"/></a><div class="content"><a class="title" href="/2023/04/12/Springboot-security(%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6)/" title="Springboot-security(权限控制)">Springboot-security(权限控制)</a><time datetime="2023-04-12T07:51:10.801Z" title="发表于 2023-04-12 15:51:10">2023-04-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/12/SpringDataElasticsearch/" title="SpringDataElasticsearch"><img src="/medias/SpringDataElasticsearch/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringDataElasticsearch"/></a><div class="content"><a class="title" href="/2023/04/12/SpringDataElasticsearch/" title="SpringDataElasticsearch">SpringDataElasticsearch</a><time datetime="2023-04-12T07:35:07.267Z" title="发表于 2023-04-12 15:35:07">2023-04-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/12/9.SpringMVC%E4%B9%8BRESTful%E9%A3%8E%E6%A0%BC/" title="9.SpringMVC之RESTful风格"><img src="/medias/spring/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="9.SpringMVC之RESTful风格"/></a><div class="content"><a class="title" href="/2023/04/12/9.SpringMVC%E4%B9%8BRESTful%E9%A3%8E%E6%A0%BC/" title="9.SpringMVC之RESTful风格">9.SpringMVC之RESTful风格</a><time datetime="2023-04-12T07:24:27.000Z" title="发表于 2023-04-12 15:24:27">2023-04-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Jilfoyle</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>